# 延时函数测试指南

## 📋 延时测试说明

系统在启动时会自动进行延时精度测试，通过数码管倒计时显示来验证延时是否准确。

---

## 🎯 测试流程

### 上电启动序列

```
1. [初始化] 数码管显示 "99" (0.5秒)
   ├─ 表示延时测试即将开始
   └─ 检查数码管是否正常工作

2. [延时测试] 倒计时显示 3→2→1→0
   ├─ 每个数字显示 1秒
   ├─ 验证 Delay_ms() 函数精度
   └─ 最后显示 "00" (2秒)

3. [硬件自检] 所有交通灯亮 1秒
   ├─ 红、黄、绿灯全亮
   ├─ 验证 Delay_s() 函数
   └─ 检查交通灯硬件连接

4. [就绪提示] 数码管显示 "88" (0.5秒)
   ├─ 表示系统初始化完成
   └─ 即将进入正常工作模式

5. [正常运行] 开始交通灯循环
   └─ 数码管显示南北/东西剩余时间
```

---

## ⏱️ 延时函数详解

### 1. Delay_ms(ms) - 毫秒延时

**原理**：使用 Timer1 模式1 实现精确延时

```c
Delay_ms(1000);  // 延时1秒（1000毫秒）
Delay_ms(500);   // 延时0.5秒
Delay_ms(10);    // 延时10毫秒
```

**精度**：
- 基于 11.0592MHz 晶振
- Timer1 16位定时器
- 理论精度：±0.01%
- 实际精度：±1% (考虑指令执行时间)

**实现**：
```c
// 1ms 定时计算
// 机器周期 = 12 / 11.0592MHz ≈ 1.085us
// 1ms 需要计数: 1000us / 1.085us ≈ 922次
// 初值 = 65536 - 922 = 64614 = 0xFC66

TH1 = 0xFC;  // 高8位
TL1 = 0x66;  // 低8位
```

### 2. Delay_us(us) - 微秒延时

**原理**：软件循环延时

```c
Delay_us(100);   // 延时100微秒
Delay_us(10);    // 延时10微秒
```

**精度**：
- 软件延时，精度约 ±5%
- 适用于短时间延时（< 1ms）
- 不适合长时间精确延时

### 3. Delay_s(sec) - 秒延时

**原理**：调用 Delay_ms(1000) 实现

```c
Delay_s(1);   // 延时1秒
Delay_s(5);   // 延时5秒
```

---

## 🧪 测试方法

### 方法1：观察数码管倒计时

1. **上电启动**，观察数码管显示
2. **数码管显示 "99"** → 准备测试
3. **倒计时 3→2→1** → 每个数字应准确显示 1 秒
4. **使用秒表对照**：
   - 从 "3" 出现开始计时
   - 到 "0" 出现应为 3.0 秒
   - 误差应 < ±0.05 秒

### 方法2：观察交通灯自检

1. **倒计时结束后**，所有交通灯亮起
2. **使用秒表测量**：
   - 从灯亮开始计时
   - 到灯灭应为 1.0 秒
   - 误差应 < ±0.02 秒

### 方法3：ISIS仿真验证

1. 在 ISIS 中加载程序
2. 使用 **虚拟示波器** 观察输出
3. 使用 **仿真时钟** 验证时间
4. 查看 **Simulation Log** 中的时间戳

---

## 📊 测试结果判断

### ✅ 延时准确标准

| 测试项 | 理论时间 | 允许误差 | 判断 |
|--------|---------|---------|------|
| 倒计时 3→2 | 1.000s | ±0.05s | 0.95s ~ 1.05s 合格 |
| 倒计时 2→1 | 1.000s | ±0.05s | 0.95s ~ 1.05s 合格 |
| 倒计时 1→0 | 1.000s | ±0.05s | 0.95s ~ 1.05s 合格 |
| 总倒计时 | 3.000s | ±0.10s | 2.90s ~ 3.10s 合格 |
| 自检时间 | 1.000s | ±0.02s | 0.98s ~ 1.02s 合格 |

### ❌ 常见问题

#### 1. 倒计时太快（< 0.9秒/次）
**原因**：
- 晶振频率设置错误（应为 11.0592MHz）
- Timer1 初值计算错误
- 编译器优化过度

**解决**：
```c
// 检查 config.h 中的晶振频率
// 确认 timer.c 中的初值：
TH1 = 0xFC;
TL1 = 0x66;
```

#### 2. 倒计时太慢（> 1.1秒/次）
**原因**：
- 晶振实际频率低于 11.0592MHz
- Timer1 初值设置错误
- 中断干扰（Timer0 中断占用时间过长）

**解决**：
```c
// 调整 Timer1 初值，减小计数值
TH1 = 0xFC;  // 可尝试 0xFB
TL1 = 0x66;  // 可尝试 0xE0
```

#### 3. 数码管不显示倒计时
**原因**：
- Display_ShowTime() 函数未正确实现
- 数码管硬件连接错误
- 动态扫描频率过低

**解决**：
- 检查 display.c 实现
- 验证硬件连接
- 增加刷新频率（timer.c 中每 10ms 刷新）

---

## 🔬 高级测试

### 使用示波器测量

如果有硬件或 ISIS 虚拟示波器：

```c
// 在 timer.c 的 Delay_1ms() 函数开始加入：
P3_6 = 1;  // 输出高电平

// 在函数结束加入：
P3_6 = 0;  // 输出低电平

// 示波器测量 P3.6 的高电平宽度应为 1ms
```

### 修改测试时间

可在 `System_Init()` 中修改测试秒数：

```c
// 原代码：
Test_DelayAccuracy(3);  // 测试3秒

// 修改为测试5秒：
Test_DelayAccuracy(5);  // 倒计时 5→4→3→2→1→0

// 修改为测试9秒：
Test_DelayAccuracy(9);  // 倒计时 9→8→...→1→0
```

---

## 📈 延时精度优化

### 如果需要更高精度

1. **使用定时器中断**（推荐）
```c
// 在 Timer0 中断中实现精确 1ms 计数
// 避免软件延时的误差累积
```

2. **校准晶振**
```c
// 根据实测结果调整 Timer 初值
// 例如：实测偏快 2%，则增加计数值
```

3. **减少中断干扰**
```c
// 延时期间临时关闭不必要的中断
EA = 0;  // 关全局中断
Delay_ms(1000);
EA = 1;  // 开全局中断
```

---

## 📝 测试记录表

| 测试次数 | 倒计时3秒实测 | 自检1秒实测 | 总误差 | 结果 |
|---------|-------------|-----------|--------|------|
| 1       |             |           |        |      |
| 2       |             |           |        |      |
| 3       |             |           |        |      |
| 平均值   |             |           |        |      |

**填写说明**：
- 使用秒表测量每次实际时间
- 计算误差 = (实测 - 理论) / 理论 × 100%
- 误差 < ±5% 为合格

---

## ✅ 验收标准

系统延时测试通过标准：
1. ✅ 数码管倒计时每秒误差 < ±50ms
2. ✅ 3秒总倒计时误差 < ±100ms
3. ✅ 自检1秒延时误差 < ±20ms
4. ✅ 连续测试3次结果稳定

**测试通过后即可进入正常交通灯运行模式。**

---

## 🚀 下一步

延时测试通过后：
1. ✅ 编译项目
2. ✅ 加载到 ISIS 仿真
3. ✅ 观察倒计时是否准确
4. ✅ 如果准确，继续验证交通灯功能

---

**提示**：延时测试是验证系统时基准确性的关键步骤，必须确保通过后再进行其他功能测试！⏱️
